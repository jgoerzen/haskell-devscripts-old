#!/usr/bin/perl -w
# arch-tag: Debhelper script for Haskell
#
# Copyright (C) 2004 John Goerzen <jgoerzen@complete.org>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

=head1 NAME

dh_haskell - Builds Cabalized libraries, calculates Haskell dependencies, and adds postinst and prerm Haskell scripts

=cut

use strict;
use File::Find;
use Debian::Debhelper::Dh_Lib;

=head1 SYNOPSIS

B<dh_haskell> [S<I<debhelper options>>] 

=head1 DESCRIPTION

dh_haskell is a debhelper program that is responsible for generating
the ${haskell:Depends} substitions and adding them to the substvars
files.  It will also add a postinst and a prerm script if required.

=cut

init();

sub is_handled_package {
    my $pkgname = shift;
    return ($pkgname =~ m/^lib(ghc5|ghc6|nhc98|hugs)-.+-dev$/);
}

sub type_of_package {
    my $pkgname = shift;
    my @pn = ($pkgname =~ m/^lib(ghc5|ghc6|nhc98|hugs)-.+-dev$/);
    return $pn[0];
    }

sub version_of_debpkg {
    my $pkgname = shift;
    return `dpkg -s $pkgname | grep ^Version | awk '{print $2}'`;
    }

sub version_of_type {
    my $pkgtype = shift;
    return version_of_debpkg($pkgtype);
}

sub upstream_version {
    my $inver = shift;
    if ($inver =~ m/-/) {
        my @v = ($inver =~ m/^(.+)-[^-]+$/);
        return $v[0];
    }
}
            

sub getcabalname {
    return `grep ^Name Setup.description | awk '{print $2}'`;
}

sub getcabalversion {
    return `grep ^Version Setup.description | awk '{print $2}'`;
}

sub getcabalnameversion {
    return getcabalname() . "-" . getcabalversion();
}

sub getcabalbasepath {
    my $pkgtype = shift;
    return "/usr/lib/haskell-packages/$pkgtype";
}

sub getcabalpkglibpath {
    my $pkgtype = shift;
    return getcabalbasepath($pkgtype) . "/lib/" . getcabalnameversion();
}

sub safesystem {
    my $program = shift;
    print "Running: $program\n";
    system($program) == 0
        or die "$program files: $?";
}

print "Generating meta-information...\n";

foreach my $package (@{$dh{DOPACKAGES}}) {
	my $tmp = tmpdir($package);

        if (is_handled_package($package)) {
            my $pkgtype = type_of_package($package);
            delsubstvar($package, "haskell:Depends");
            addsubstvar($package, "haskell:Depends", 
                        $pkgtype, ">= " . upstream_version(version_of_type($pkgtype)));
            addsubstvar($package, "haskell:Depends",
                        $pkgtype, "<< " . upstream_version(version_of_type($pkgtype)) . "-999");
            
            if ($pkgtype eq "ghc5" || $pkgtype eq "ghc6") {
                # Build scripts
                my $ghcver = "ghc-" . upstream_version(version_of_type($pkgtype));
                my $pkglibdir = getcabalpkglibpath($pkgtype);
                my $cabalname = getcabalname();
                my $cabalversion = getcabalversion();
                autoscript($package,"postinst","postinst-ghc",
                           "s%#GHCVER#$ghcver%;s%#PKGLIBDIR#%$pkglibdir%");
                autoscript($package,"prerm","prerm-ghc",
                           "s%#GHCVER#$ghcver%;s%#PKGLIBDIR#%$pkglibdir%;s%#CABALNAME#%$cabalname%;s%#CABALVERSION#%$cabalversion%");
            }
        }

}

print "Building setup...\n";
safesystem("ghc6 -package Cabal Setup.lhs -o setup");

foreach my $package (@{$dh{DOPACKAGES}}) {
    my $tmp = tmpdir($package);
    if (is_handled_package($package)) {
        my $pkgtype = type_of_package($package);
        
        print "\n ****************************************** \n";
        print " NOW BUILDING $package FOR $pkgtype\n";
        print " OUTPUT TO $tmp\n\n";
        
        print "Cleaning...";
        system("./setup clean");
        safesystem("rm -f .*config*");
        
        safesystem("./setup configure --prefix=" . getcabalbasepath($pkgtype)
                   . " --with-compiler=/usr/bin/$pkgtype");
        safesystem("./setup build");
        safesystem("mkdir -p $tmp/usr/share/doc/$package");
        safesystem("mkdir -p $tmp" . getcabalbasepath($pkgtype));
        safesystem("./setup install --install-prefix=$tmp" . getcabalbasepath($pkgtype));
        safesystem("cp .installed-pkg-config $tmp" . getcabalpkglibpath($pkgtype));
        print " Build for $pkgtype complete.\n";
    }
}


=head1 SEE ALSO

L<debhelper(7)>

=head1 AUTHOR

John Goerzen <jgoerzen@complete.org>

Based on ideas in dh_python by Josselin Mouette <joss@debian.org>

=cut
